function I(e){return Array.isArray(e)?e:[e]}const G={STOP:"STOP"};function M(e,t){const n=t(e);e.children!==void 0&&n!==G.STOP&&e.children.forEach(i=>M(i,t))}function F(e,t={}){const{preserveGroup:n=!1}=t,i=[],s=n?r=>{r.isLeaf||(i.push(r.key),o(r.children))}:r=>{r.isLeaf||(r.isGroup||i.push(r.key),o(r.children))};function o(r){r.forEach(s)}return o(e),i}function R(e,t){const{isLeaf:n}=e;return n!==void 0?n:!t(e)}function j(e){return e.children}function U(e){return e.key}function q(){return!1}function V(e,t){const{isLeaf:n}=e;return!(n===!1&&!Array.isArray(t(e)))}function W(e){return e.disabled===!0}function Z(e,t){return e.isLeaf===!1&&!Array.isArray(t(e))}function P(e){var t;return e==null?[]:Array.isArray(e)?e:(t=e.checkedKeys)!==null&&t!==void 0?t:[]}function x(e){var t;return e==null||Array.isArray(e)?[]:(t=e.indeterminateKeys)!==null&&t!==void 0?t:[]}function z(e,t){const n=new Set(e);return t.forEach(i=>{n.has(i)||n.add(i)}),Array.from(n)}function B(e,t){const n=new Set(e);return t.forEach(i=>{n.has(i)&&n.delete(i)}),Array.from(n)}function H(e){return(e==null?void 0:e.type)==="group"}class J extends Error{constructor(){super(),this.message="SubtreeNotLoadedError: checking a subtree whose required nodes are not fully loaded."}}function Q(e,t,n,i){return w(t.concat(e),n,i,!1)}function X(e,t){const n=new Set;return e.forEach(i=>{const s=t.treeNodeMap.get(i);if(s!==void 0){let o=s.parent;for(;o!==null&&!(o.disabled||n.has(o.key));)n.add(o.key),o=o.parent}}),n}function Y(e,t,n,i){const s=w(t,n,i,!1),o=w(e,n,i,!0),r=X(e,n),c=[];return s.forEach(f=>{(o.has(f)||r.has(f))&&c.push(f)}),c.forEach(f=>s.delete(f)),s}function E(e,t){const{checkedKeys:n,keysToCheck:i,keysToUncheck:s,indeterminateKeys:o,cascade:r,leafOnly:c,checkStrategy:f,allowNotLoaded:u}=e;if(!r)return i!==void 0?{checkedKeys:z(n,i),indeterminateKeys:Array.from(o)}:s!==void 0?{checkedKeys:B(n,s),indeterminateKeys:Array.from(o)}:{checkedKeys:Array.from(n),indeterminateKeys:Array.from(o)};const{levelTreeNodeMap:h}=t;let d;s!==void 0?d=Y(s,n,t,u):i!==void 0?d=Q(i,n,t,u):d=w(n,t,u,!1);const v=f==="parent",N=f==="child"||c,g=d,A=new Set,C=Math.max.apply(null,Array.from(h.keys()));for(let b=C;b>=0;b-=1){const L=b===0,S=h.get(b);for(const a of S){if(a.isLeaf)continue;const{key:l,shallowLoaded:p}=a;if(N&&p&&a.children.forEach(y=>{!y.disabled&&!y.isLeaf&&y.shallowLoaded&&g.has(y.key)&&g.delete(y.key)}),a.disabled||!p)continue;let K=!0,k=!1,m=!0;for(const y of a.children){const O=y.key;if(!y.disabled){if(m&&(m=!1),g.has(O))k=!0;else if(A.has(O)){k=!0,K=!1;break}else if(K=!1,k)break}}K&&!m?(v&&a.children.forEach(y=>{!y.disabled&&g.has(y.key)&&g.delete(y.key)}),g.add(l)):k&&A.add(l),L&&N&&g.has(l)&&g.delete(l)}}return{checkedKeys:Array.from(g),indeterminateKeys:Array.from(A)}}function w(e,t,n,i){const{treeNodeMap:s,getChildren:o}=t,r=new Set,c=new Set(e);return e.forEach(f=>{const u=s.get(f);u!==void 0&&M(u,h=>{if(h.disabled)return G.STOP;const{key:d}=h;if(!r.has(d)&&(r.add(d),c.add(d),Z(h.rawNode,o))){if(i)return G.STOP;if(!n)throw new J}})}),c}function $(e,{includeGroup:t=!1,includeSelf:n=!0},i){var s;const o=i.treeNodeMap;let r=e==null?null:(s=o.get(e))!==null&&s!==void 0?s:null;const c={keyPath:[],treeNodePath:[],treeNode:r};if(r!=null&&r.ignored)return c.treeNode=null,c;for(;r;)!r.ignored&&(t||!r.isGroup)&&c.treeNodePath.push(r),r=r.parent;return c.treeNodePath.reverse(),n||c.treeNodePath.pop(),c.keyPath=c.treeNodePath.map(f=>f.key),c}function ee(e){if(e.length===0)return null;const t=e[0];return t.isGroup||t.ignored||t.disabled?t.getNext():t}function te(e,t){const n=e.siblings,i=n.length,{index:s}=e;return t?n[(s+1)%i]:s===n.length-1?null:n[s+1]}function _(e,t,{loop:n=!1,includeDisabled:i=!1}={}){const s=t==="prev"?ne:te,o={reverse:t==="prev"};let r=!1,c=null;function f(u){if(u!==null){if(u===e){if(!r)r=!0;else if(!e.disabled&&!e.isGroup){c=e;return}}else if((!u.disabled||i)&&!u.ignored&&!u.isGroup){c=u;return}if(u.isGroup){const h=T(u,o);h!==null?c=h:f(s(u,n))}else{const h=s(u,!1);if(h!==null)f(h);else{const d=re(u);d!=null&&d.isGroup?f(s(d,n)):n&&f(s(u,!0))}}}}return f(e),c}function ne(e,t){const n=e.siblings,i=n.length,{index:s}=e;return t?n[(s-1+i)%i]:s===0?null:n[s-1]}function re(e){return e.parent}function T(e,t={}){const{reverse:n=!1}=t,{children:i}=e;if(i){const{length:s}=i,o=n?s-1:0,r=n?-1:s,c=n?-1:1;for(let f=o;f!==r;f+=c){const u=i[f];if(!u.disabled&&!u.ignored)if(u.isGroup){const h=T(u,t);if(h!==null)return h}else return u}}return null}const ie={getChild(){return this.ignored?null:T(this)},getParent(){const{parent:e}=this;return e!=null&&e.isGroup?e.getParent():e},getNext(e={}){return _(this,"next",e)},getPrev(e={}){return _(this,"prev",e)}};function se(e,t){const n=t?new Set(t):void 0,i=[];function s(o){o.forEach(r=>{i.push(r),!(r.isLeaf||!r.children||r.ignored)&&(r.isGroup||n===void 0||n.has(r.key))&&s(r.children)})}return s(e),i}function ae(e,t){const n=e.key;for(;t;){if(t.key===n)return!0;t=t.parent}return!1}function D(e,t,n,i,s,o=null,r=0){const c=[];return e.forEach((f,u)=>{var h;const d=Object.create(i);if(d.rawNode=f,d.siblings=c,d.level=r,d.index=u,d.isFirstChild=u===0,d.isLastChild=u+1===e.length,d.parent=o,!d.ignored){const v=s(f);Array.isArray(v)&&(d.children=D(v,t,n,i,s,d,r+1))}c.push(d),t.set(d.key,d),n.has(r)||n.set(r,[]),(h=n.get(r))===null||h===void 0||h.push(d)}),c}function le(e,t={}){var n;const i=new Map,s=new Map,{getDisabled:o=W,getIgnored:r=q,getIsGroup:c=H,getKey:f=U}=t,u=(n=t.getChildren)!==null&&n!==void 0?n:j,h=t.ignoreEmptyChildren?a=>{const l=u(a);return Array.isArray(l)?l.length?l:null:l}:u,d=Object.assign({get key(){return f(this.rawNode)},get disabled(){return o(this.rawNode)},get isGroup(){return c(this.rawNode)},get isLeaf(){return R(this.rawNode,h)},get shallowLoaded(){return V(this.rawNode,h)},get ignored(){return r(this.rawNode)},contains(a){return ae(this,a)}},ie),v=D(e,i,s,d,h);function N(a){if(a==null)return null;const l=i.get(a);return l&&!l.isGroup&&!l.ignored?l:null}function g(a){if(a==null)return null;const l=i.get(a);return l&&!l.ignored?l:null}function A(a,l){const p=g(a);return p?p.getPrev(l):null}function C(a,l){const p=g(a);return p?p.getNext(l):null}function b(a){const l=g(a);return l?l.getParent():null}function L(a){const l=g(a);return l?l.getChild():null}const S={treeNodes:v,treeNodeMap:i,levelTreeNodeMap:s,maxLevel:Math.max(...s.keys()),getChildren:h,getFlattenedNodes(a){return se(v,a)},getNode:N,getPrev:A,getNext:C,getParent:b,getChild:L,getFirstAvailableNode(){return ee(v)},getPath(a,l={}){return $(a,l,S)},getCheckedKeys(a,l={}){const{cascade:p=!0,leafOnly:K=!1,checkStrategy:k="all",allowNotLoaded:m=!1}=l;return E({checkedKeys:P(a),indeterminateKeys:x(a),cascade:p,leafOnly:K,checkStrategy:k,allowNotLoaded:m},S)},check(a,l,p={}){const{cascade:K=!0,leafOnly:k=!1,checkStrategy:m="all",allowNotLoaded:y=!1}=p;return E({checkedKeys:P(l),indeterminateKeys:x(l),keysToCheck:a==null?[]:I(a),cascade:K,leafOnly:k,checkStrategy:m,allowNotLoaded:y},S)},uncheck(a,l,p={}){const{cascade:K=!0,leafOnly:k=!1,checkStrategy:m="all",allowNotLoaded:y=!1}=p;return E({checkedKeys:P(l),indeterminateKeys:x(l),keysToUncheck:a==null?[]:I(a),cascade:K,leafOnly:k,checkStrategy:m,allowNotLoaded:y},S)},getNonLeafKeys(a={}){return F(v,a)}};return S}export{le as c};
